// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "forge-std/Test.sol";
import "../src/Auctions.sol";
import "../src/BidTicket.sol";
import "./lib/Mock721.sol";
import "./lib/Mock1155.sol";

contract AuctionsVulnerabilityPoC is Test {
    Auctions public auctions;
    BidTicket public bidTicket;
    Mock721 public mock721;
    Mock1155 public mock1155;

    address public theBarn;
    address public user1;
    address public user2;
    address public owner;

    uint256[] public tokenIds = [0, 1, 2];

    function setUp() public {
        owner = address(this);
        theBarn = vm.addr(1);
        user1 = vm.addr(2);
        user2 = vm.addr(3);

        bidTicket = new BidTicket(owner);
        auctions = new Auctions(owner, theBarn, address(bidTicket));
        mock721 = new Mock721();
        mock1155 = new Mock1155();

        bidTicket.setAuctionsContract(address(auctions));
        bidTicket.mint(user1, 1, 100);
        bidTicket.mint(user2, 1, 100);

        vm.deal(user1, 10 ether);
        vm.deal(user2, 10 ether);

        mock721.mint(theBarn, 10);
        vm.prank(theBarn);
        mock721.setApprovalForAll(address(auctions), true);
    }

    function test_VulnerabilityPoC() public {
        // Step 1: Set up an auction
        vm.prank(user1);
        auctions.startAuctionERC721{value: 0.05 ether}(0.05 ether, address(mock721), tokenIds);

        uint256 auctionId = auctions.nextAuctionId() - 1;

        // Step 2: Simulate normal bidding
        vm.prank(user2);
        auctions.bid{value: 0.06 ether}(auctionId, 0.06 ether);

        // Step 3: End the auction and claim
        vm.warp(block.timestamp + 7 days);
        vm.prank(user2);
        auctions.claim(auctionId);

        // Step 4: Attempt to withdraw as owner
        uint256 initialBalance = address(auctions).balance;
        uint256 ownerInitialBalance = owner.balance;

        uint256[] memory auctionIds = new uint256[](1);
        auctionIds[0] = auctionId;

        vm.expectRevert(abi.encodeWithSignature("TransferFailed()"));
        auctions.withdraw(auctionIds);

        assertEq(address(auctions).balance, initialBalance, "Contract balance should not change");
        assertEq(owner.balance, ownerInitialBalance, "Owner balance should not change");

        // Severity assessment
        console.log("Vulnerability PoC Results:");
        console.log("1. Ether trapped in contract: ", address(auctions).balance);
        console.log("2. Owner cannot withdraw trapped Ether: Yes");
        console.log("Severity: High");
        console.log("This vulnerability prevents the owner from withdrawing Ether from completed auctions, potentially leading to loss of funds.");
    }
}